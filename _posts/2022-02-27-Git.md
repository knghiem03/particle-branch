---
layout: post
title: Head First Git Summary 
tags: [Katex, Markdown]
---

## Git Cheat Sheet from Head First Git book

### Section 1: Get Going with Git

- To initialize Git you use the init command, like so: git init

- The result of initializing a new Git repository is that Git will create a hidden folder called .git in the directory where you ran the git init command. This hidden folder is used by Git to store your snapshots, as well as some configuration for Git itself.

- Any directory that is managed by Git is referred to as the working directory.

- Git, by design, has an index, which acts as a **staging area** To add files to the index, you use the git add <filename> command.

- Committing in Git translates to taking a snapshot of the changes that were stored in the index. The command to create a commit is git commit, which requires that you supply it with a commit message to describe the changes you are commiting, using the -m (or --message) flag:

- git commit -m “some message”

- Every file in the working directory is assigned one or more states.

- A brand new file added to the working directory is marked as “untracked,” which suggests that Git does not know about this file.

- Adding a new file to Git’s index does two things—it marks the file as being “tracked” and creates a copy of that file into the index.

- When you make a commit, Git creates a copy of the files in the index and stores them in the object database. It also creates a commit object that records metadata about the commit, including a pointer to the files that were just stored, the author name and email, and the time the commit was made, as well as the commit message.

- Every commit in Git is identified by a unique identifier, refererred to as the commit ID.

- At any time you can ask Git for the status of the files in the working directory and the Git repository, using the git status command.

- Every commit except the initial commit in Git stores the commit ID of the commit that appeared just before it, thus creating a string of commits, like leaves on a branch.

### Section 2: Branching

- Branches are one of Git’s best features. Branches allow you to work on multiple tasks at the same time.

- When working in Git, you are always working on a branch. Every repository starts with a branch and defaults to the name master.

- The master branch is not special in any way. It’s no different than any other branch you create. You can rename or even delete the master branch.

- The primary command to work with branches is git branch. You can use git branch to create, list, and delete branches.

- To create a branch called update-profile, supply the name to git branch like so: git branch update-profile

- git branch allows you to create branches, but to start using the new branch, use the git switch command. Supply it with the name of the branch you wish to start using, like so: git switch update-profile

- Think of a branch as a sticky note that contains the branch name and the commit ID of the last commit on that branch.

- Every time you make a commit on a branch, Git updates the sticky note that represents that branch, giving it the new commit ID. This is how a branch “moves.”

- Since branches always point to commits, they offer an easy way to create other branches.

- Whenever you switch branches, Git rewrites the working directory to reflect the state captured in the latest commit on that branch.

- In a typical workflow, some branches (by convention) are treated as “integration” branches to collect the work done in other branches.

- In contrast, day-to-day work is done in **feature** branches. Each feature branch is to be used for one thing and one thing only: for example, to introduce a new feature, or fix a bug.

- To combine the work you’ve done in an integration branch, you merge the feature branch into the integration branch.

- The easiest kind of merge is called a **fast-forward merge**, in which one branch simply “catches up” with another branch.

- The other kind of merge is when you merge two branches that have diverged from one another, in which case Git will create a merge commit.

- A merge commit is like any other commit, except it’s created by Git and has not one but two parents—the first parent is the latest commit on the integration branch, and the second parent is the latest commit on the feature branch.

- Occasionally, the same line in the same file has been modified in the two branches being merged, causing a merge conflict. Git relies on you to resolve the merge conflict.

- You can delete a branch using the git branch command, along with the -d (or --delete) flag.

- If you attempt to delete a branch that has not been merged yet, Git will error out. If you are absolutely sure you want to delete an unmerged branch, you’ll have to use the -D (uppercase “D”) flag with the git branch command.

- A branch is always based on a commit. If you know the ID of the commit you want to use as the basis for a branch, you can supply it to the git branch command:

- git branch branch-name commit-ID

### Section 3:  Know your repo - Looking around

```
git log --oneline  
git log --oneline --all --graph
git diff (index-old or a or ---) (working directory-new or b or +++)
git diff - -word-diff (words differ instead of lines differ)
git diff compares index and working directory
git diff --cached to compare object database to index
git diff --staged to compare object database to index. When staged, a is object database an b is index
```

Compare branches
8. git diff target-branch source-branch -- if merge source to target 

Compare commits
9. git diff target (older version) source (newer version)

- The git log command shows us the commit history of our repository.

- The git log command, by default, lists all the commits, along with the commit metadata, for the current branch.

- Flags like --abbrev-commit, --pretty with the oneline option, or the --oneline flag make it easier to visualize the commit history of a single branch.

- Using the --all and --graph flags with the git log command allow us to visualize the history of every branch in our repository.

- Git tracks **changes—between** the working directory and the index, and index and the object database.

- To find out what changed between the index and the working directory, use the git diff command. The default behavior of the git diff command is to compare the index and the working directory.

- The output of the git diff command starts by telling you which file’s differences are currently being displayed. Typically, one set of changes is prefixed with “a,” and the other is marked by “b”:

- diff --git a/resume.md b/resume.md

- This is followed by a legend that tells how the log output will differentiate between lines that exist in “a” versus “b”:

1. --- a/resume.md

2. +++ b/resume.md

- The legend is followed by a series of “hunks” that allow you to see the changes in bite-sized pieces. Each hunk has lines prefixed with a minus (meaning it comes from the version of the file prefixed with “a/”), or a plus (meaning it is present in the fil- Git will display as many, and only as many, hunks as needed to display all the differences. This makes it easier to compare large files.

- The --cached (or --staged) flag for the diff command allows us to compare the changes that we last committed: that is, the changes in Git’s object database with the changes added to the index.

- We can supply the git diff command with two branch names. In such a case, git diff will compare the differences between the “tips” of the two branches.

- The git diff command is always comparing two sets of changes, which can be visualized by a Venn diagram. The first argument is the set on the left (always indicated by “a/”) and prefixed with a minus (“-”). The second argument is the set of the right, indicated by “b/”, and prefixed with a “+”.

- Swapping the order of the arguments swaps the left-hand and right-hand sides of the Venn diagram.

- We can use the git log command to identify commit IDs, which in turn we can supply to the git diff command to compare two disparate commits.

### Section 4:  Make mistakes and how to correct

1. git restore is the opposite of git add
2. git restore file-name move index version back to working directory
3. git restore file1 file2 file3
4. git restore --staged file-name (copy that file from object database back to index directory)
5. git restore --staged is the opposite of git commit
6. git rm delete the copy in working directory and index, possible to restore by git restore
7. git rm -r for removing directory
8. git commit --amend -m "this msg replaces the old commit msg"
9. git branch -m old-branch-name new-branch-name
10. Git offers you several ways to undo your changes.

- The git restore command allows you to undo changes to one or more files—both in the working directory and the index. You can supply git restore with a list of file paths.

- The git restore command, by default, undoes changes in the working directory by replacing them with the version of the file that was last added to the index.

- To undo changes to files that have been already added to the index, you can also use the git restore command. However, you will need to supply it with the --staged flag.

- The git restore --staged command will replace the contents of the files in the index with the version that was last committed.

- You can delete files that you previously committed to Git with the git rm command.

- The git rm command, like the git restore command, takes a list of file paths. It then removes the files from the working directory and the index.

- You are still required to make a commit to record the fact that you deleted one or more files. That is, removing files is a two-step process—git rm removes the files from the working directory and the index, and the subsequent commit records the deletion.

- You can edit commit messages with the git commit command along with the --amend flag.

- You should only amend the tips of branches.

- When you amend a commit, you are not actually changing a commit. Git records a new commit with the new commit message and replaces the previous commit in your commit history. Git will eventually delete the older commit.

- Git allows you to rename branches by using the git branch command with the -m (or --move) flag.

- The commit you are on is referred to as HEAD. HEAD is a reference to a commit.

- HEAD is how Git knows which branch you are on; it’s a lot like the pin in a map that shows your location. HEAD is updated every time you switch or merge branches.

- The commit that HEAD points to will be the parent of the next commit in the repository.

- Git offers two operators to reference ancestor commits relative to HEAD. You have the tilde (~) operator to reference parents of the current commit. HEAD~2, for example, takes you back two generations: it represents the grandparent of the current commit.

- You can use the caret (^) operator to reference the parents of a merge commit. HEAD^1 points to the first parent, and HEAD^2 points to the second.

- The tilde and caret operators make it easier to supply commits to commands like git diff, saving you from having to copy-paste commit IDs.

- Git offers two different ways to undo commits. The git reset command moves the HEAD and the branch “sticky note” to a different commit.

- The git reset command has three different modes—soft, mixed, and hard. Each one has a different effect on the changes that were recorded in the commit that was undone.

- Be warned! The git reset command in “hard” mode is destructive: if you use it, you will lose your changes. So don’t use it.

- git reset allows you to “time travel,” in effect, because it moves you to a previous commit.

- Another way to undo a commit is with the git revert command, which creates an “anti-commit”—a commit that introduces a set of changes that are the exact opposite of the commit that you wish to undo.

###  Section 5: Collabrorate - Remote Work

- Git offers you several ways to undo your changes.

- The git restore command allows you to undo changes to one or more files—both in the working directory and the index. You can supply git restore with a list of file paths.

- The git restore command, by default, undoes changes in the working directory by replacing them with the version of the file that was last added to the index.

- To undo changes to files that have been already added to the index, you can also use the git restore command. However, you will need to supply it with the --staged flag.

- The git restore --staged command will replace the contents of the files in the index with the version that was last committed.

- You can delete files that you previously committed to Git with the git rm command.

- The git rm command, like the git restore command, takes a list of file paths. It then removes the files from the working directory and the index.

- You are still required to make a commit to record the fact that you deleted one or more files. That is, removing files is a two-step process—git rm removes the files from the working directory and the index, and the subsequent commit records the deletion.

- You can edit commit messages with the git commit command along with the --amend flag.

- You should only amend the tips of branches.

- When you amend a commit, you are not actually changing a commit. Git records a new commit with the new commit message and replaces the previous commit in your commit history. Git will eventually delete the older commit.

- Git allows you to rename branches by using the git branch command with the -m (or --move) flag.

- The commit you are on is referred to as HEAD. HEAD is a reference to a commit.

- HEAD is how Git knows which branch you are on; it’s a lot like the pin in a map that shows your location. HEAD is updated every time you switch or merge branches.

- The commit that HEAD points to will be the parent of the next commit in the repository.

- Git offers two operators to reference ancestor commits relative to HEAD. You have the tilde (~) operator to reference parents of the current commit. HEAD~2, for example, takes you back two generations: it represents the grandparent of the current commit.

- You can use the caret (^) operator to reference the parents of a merge commit. HEAD^1 points to the first parent, and HEAD^2 points to the second.

- The tilde and caret operators make it easier to supply commits to commands like git diff, saving you from having to copy-paste commit IDs.

- Git offers two different ways to undo commits. The git reset command moves the HEAD and the branch “sticky note” to a different commit.

- The git reset command has three different modes—soft, mixed, and hard. Each one has a different effect on the changes that were recorded in the commit that was undone.

- Be warned! The git reset command in “hard” mode is destructive: if you use it, you will lose your changes. So don’t use it.

- git reset allows you to “time travel,” in effect, because it moves you to a previous commit.

- Another way to undo a commit is with the git revert command, which creates an “anti-commit”—a commit that introduces a set of changes that are the exact opposite of the commit that you wish to undo.

### Section 6:  Collabrorate - With Team

- Git shines at collaboration. It allows multiple contributors to work on a shared repository. Every contributor can clone the same repository and work independent of others.

- Your clone is unaware of any changes that occur in the remote, including branches and commits that collaborators push to the remote.

- The git pull command updates a specific branch. It fetches all new commits on the remote and updates the local branch’s commit history to look like the remote’s.

- Git uses remote tracking branches as liaisons between local branches in a clone and their counterparts in the remote.

- Remote tracking branches are branches that are fully managed by Git. Git creates, updates, and deletes them.

- Git uses remote tracking branches to know which branch in the remote should be updated when you push a local branch to the remote.

- When you push a new branch to the remote, you have to set the upstream. Git records the upstream as a remote tracking branch.

- Git offers another command, git fetch, that retrieves all new branches and commits in the remote, then updates the remote tracking branches in the clone. The git fetch command does not affect the local branches in the clone.

- You can use the -a (shorthand for --all) flag with the git branch command to see all the branches in your clone, including local and remote tracking branches.
 
- You can also use the very verbose (-vv) flag with the the git branch command to list all your branches alongside their remote tracking branches (if any).

- To work on a branch that somebody else created and pushed to the remote, you can use the git switch command (like you would any other branch). Git will create a new local branch with the same name as the remote tracking branch. This allows multiple people to share their work.

- If you add commits to a local branch that has an associated remote tracking branch, Git can compare the commits and inform you that you need to push.

- Prior to pushing, it’s good practice to first fetch. Since fetch only updates the remote tracking branches, Git can tell you if the local branch has diverged away from the remote branch.

- To update the local branch with any commits on the remote tracking branch, you can merge the remote tracking branch into the local branch.

- These two steps—git fetch followed by git merge—are what git pull does.

- It’s best to avoid using the command git pull. Instead, use git fetch followed by git merge. This gives you the opportunity to think about what you want to do if your local branch has diverged away from the remote.

- The git fetch command supports a prune (-p or --prune) flag. This updates the remote tracking branches in your clone with all new branches and commits. It also deletes any remote tracking branches that no longer exist in the remote.

- Listing all your branches with the -vv flag will mark any remote branch that has been deleted as “gone,” indicating that the local branch no longer has a remote counterpart.



